# C++基础

# 常用设计模式

# 链表、栈、队列、树 

## Heap,Trie、BST、AVL、B+ Tree

# 进程间通信线程同步，多线程编程模型

# TCP/IP 四层模型

TCP/IP四层模型分别是应用层，传输层，网络层，网络接口层。

应用层是用户日常中接触到的，一些应用软件等就是处于应用层，应用层工作在操作系统的用户态，而其他层都工作在内核态，它只负责将数据发送给传输层，对于下层如何将数据传输给目的地是不感知的。

应用之间需要传输数据的时候会先将数据给传输层处理，传输层最常见的的两个协议就是TCP和UDP，这两个的主要区别是，一个是可靠性传输，一个是尽最大努力传输，TCP在建立连接时需要进行三次握手，保证了发送端和接收端都有收发能力才算建立链接成功，还存在一些传输控制技术，如拥塞控制，流量控制，校验技术，超时重传等来保证数据正确有序的到达。而UDP则没有这些保证，但是正因为没有这些技术的处理，导致它的传输效率会比TCP高很多，在不需要正确性保证的业务场景下，UDP会是更好的选择。当然，在日常中，一般是多个应用进程同时收发数据，这时我们使用端口来识别不同应用的数据，常见的端口22，就是远程服务器常用，80，是web服务器使用

在传输层，并不会将数据越过千山万水发送到目的端，这个过程是由网络层来完成，网络层的IP协议，给设备分配了IP地址，现在常用的有ipv4和ipv6，ipv4是32位的，通过网络号和主机号构成，网络号识别在哪个网络区域，主机号来识别同一个子网下的不同主机。网络号是通过子网掩码按位与运算得到。在网络环境中，存在很多设备，交换机，路由器，主机等，IP协议通过路由算法，找到对应的子网，再找到对应的主机，将数据通过网络发送子网。

在网络协议层，会将网络层加了IP头部的数据再包一层，加上MAC头部，才能发送到对应的设备，因为在以太网，是通过MAC地址来识别唯一的主机号的，而这个MAC地址是通过ARP地址解析协议来获得，获得了目的MAC地址和源MAC地址后，就可以将数据发送到目的地了。

#  Socket 网络编程

# 事务管理

# MVCC、OCC、2PL实现

## 2PL

在一个事务里面，分为加锁(lock)阶段和解锁(unlock)阶段,从 begin 开始，一直到 commit/rollback，都是加锁阶段，换句话说，整个事务期间，线程只抓取锁，不释放锁，直到事务结束，统一释放。使用lock_guard实现

# raft 共识 Paxos共识

# Gossip 传播

# CAP 定理

# 一致性模型

# 主备、多主、分片

# quorum 协议

# 2PC实现 3PC

# LSM 树

# Calvin、Spanner、Aurora、Neo4j

# CRDT

# ZeroMQ 通信框架,其他消息队列

# Protocbuf

# 线程亲和性

# 数据库日志

