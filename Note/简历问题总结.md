# C++基础

# 常用设计模式

# 链表、栈、队列、树 

## Heap,Trie、BST、AVL、B+ Tree

# 进程间通信线程同步，多线程编程模型

# TCP/IP 四层模型

TCP/IP四层模型分别是应用层，传输层，网络层，网络接口层。

应用层是用户日常中接触到的，一些应用软件等就是处于应用层，应用层工作在操作系统的用户态，而其他层都工作在内核态，它只负责将数据发送给传输层，对于下层如何将数据传输给目的地是不感知的。

应用之间需要传输数据的时候会先将数据给传输层处理，传输层最常见的的两个协议就是TCP和UDP，这两个的主要区别是，一个是可靠性传输，一个是尽最大努力传输，TCP在建立连接时需要进行三次握手，保证了发送端和接收端都有收发能力才算建立链接成功，还存在一些传输控制技术，如拥塞控制，流量控制，校验技术，超时重传等来保证数据正确有序的到达。而UDP则没有这些保证，但是正因为没有这些技术的处理，导致它的传输效率会比TCP高很多，在不需要正确性保证的业务场景下，UDP会是更好的选择。当然，在日常中，一般是多个应用进程同时收发数据，这时我们使用端口来识别不同应用的数据，常见的端口22，就是远程服务器常用，80，是web服务器使用

在传输层，并不会将数据越过千山万水发送到目的端，这个过程是由网络层来完成，网络层的IP协议，给设备分配了IP地址，现在常用的有ipv4和ipv6，ipv4是32位的，通过网络号和主机号构成，网络号识别在哪个网络区域，主机号来识别同一个子网下的不同主机。网络号是通过子网掩码按位与运算得到。在网络环境中，存在很多设备，交换机，路由器，主机等，IP协议通过路由算法，找到对应的子网，再找到对应的主机，将数据通过网络发送子网。

在网络协议层，会将网络层加了IP头部的数据再包一层，加上MAC头部，才能发送到对应的设备，因为在以太网，是通过MAC地址来识别唯一的主机号的，而这个MAC地址是通过ARP地址解析协议来获得，获得了目的MAC地址和源MAC地址后，就可以将数据发送到目的地了。

#  Socket 网络编程

# 事务管理

# MVCC、OCC、2PL实现

OCC silo PT-OCC tiktoc LTOCC

## 2PL

在一个事务里面，分为加锁(lock)阶段和解锁(unlock)阶段,从 begin 开始，一直到 commit/rollback，都是加锁阶段，换句话说，整个事务期间，线程只抓取锁，不释放锁，直到事务结束，统一释放。使用lock_guard实现

# raft 共识 Paxos共识

1. Raft是什么？为什么不写Paxos？
2. Raft选举讲一下
3. Raft逻辑时钟会不会倒退
4. Raft日志同步
5. Raft脑裂
6. 基于Raft的应用如何写raft，说出流程。
7. 日志是如何提交的？
8. 日志回退情况（尚未提交日志的leader挂掉）？
9. 何为日志最新？与选主的关系？
10. 快照是什么？快照流程。Why the design？
11. 为什么不设计成让follower自己做快照？
12. 快照时间多久合适？为什么？
13. 你这个发送快照的方式工程上是否可行？存在哪些问题？不可行的话请给出实现方法。（我说的类似AOF + RDB，尽量缩减checkpoints之间的时间）
14. 快照和日志同步同时发生怎么处理？不能用加锁的方式。
15. 了解过开源的日志同步和快照机制没有？
16. Multi-Raft结构？

# Gossip 传播

# CAP 定理

# 一致性模型

# 主备、多主、分片

# quorum 协议

# 2PC实现 3PC

# LSM 树

# Calvin、Spanner、Aurora、Neo4j

传统分布式事务处理使用到了锁来保证并发竞争的事务满足隔离级别的约束 ， 比如，序列化级别保证了事务是一个接一个运行的。而每个副本的执行顺序是无法预测的，但结果是可以预测的。  Calvin 这种确定性数据库的方案是让事务在每个副本上的执行顺序达到一致，那么执行结果也肯定是一致的。  这样做的好处是避免了众多事务之间的锁竞争，从而大大提高了高并发度事务的吞吐量。同时，节点崩溃不影响事务的执行。因为事务执行步骤已经分配，节点恢复后从失败处接着运行该事务即可，**这种模式使分布式事务的可用性也大大提高**。

# CRDT

# ZeroMQ 通信框架,其他消息队列

# Protocbuf

# 线程亲和性

# 数据库日志

# 项目

#### 面向跨区域高可用的 Coordination-Free 分布式事务处理机制

CCF 华为创新研究计划, 基于华为 openGauss 构建跨区域多主数据库。在熟悉 openGauss 数据库事务
处理代码的基础上解决以下问题：
• 多主架构：提高业务相应速度，将主从架构下的从节点提升为主节点，即多主全复制数据库。
• 强一致性：用 epoch 划分时间，保证 epoch 级别的强一致性；C++ 多线程编程。
• 跨节点写写冲突：使用确定性规则进行冲突合并，采用托马斯写原则；
• 高性能：使用 ZeroMQ 通信框架和 Epoch 内的流水线发送实现高效通信，Protocbuf 序列化工具传输
的数据进行压缩，乐观并发控制 OCC 等技术实现高性能。

#### 基于无协调强一致性技术的多主架构云原生数据库 

CCF-华为胡杨林基金数据库专项利用上一个项目研究的无协调分布式事务处理机制设计成一个模块，
目的将数据库存储层计算层解耦，扩展成存算分离架构，以支持云原生数据库特性。
• 存算分离: 存储和计算节点完全解耦，事务处理层作为存储和计算的中间件协调事务执行。
• 可移植性: 通过编写接口适配如 KV，SQL，GQL 等多种数据模型；以及如 RocksDB，LevelDB 等多
种存储引擎，大幅提高系统的可扩展性。

#### QStore 分布式分片数据库的复现及 Raft 保证高可用 

• 并发控制: 基于 QStore 论文实现事务并发控制协议，数据分片处理并将事务按数量划分成 epoch 后以
epoch 粒度提交。
• 优先级队列: 将事务按涉及数据分片划分成子事务后进入优先级队列，后根据优先级队列以及多分区
线程执行提交子事务，并保证事务的原子性，同时为多分区线程设置线程亲和性，降低调度开销。
• 系统高可用: 使用 Raft 共识实现数据库容错，支持选主、日志同步、状态持久化、日志恢复等功能。
